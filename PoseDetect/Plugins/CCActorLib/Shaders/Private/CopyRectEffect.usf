// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
    LensDistortionUVGeneration.usf: Generate lens distortion and undistortion
    UV displacement map into a render target.

    The pixel shader directly compute the distort viewport UV to undistort
    viewport UV displacement using Sv_Position and the reference equations and
    store them into the red and green channels.

    However to avoid resolving with a ferrari method, or doing a newton method
    on the GPU to compute the undistort viewport UV to distort viewport UV
    displacement, this couple of shaders works as follow: The vertex shader
    undistort the grid's vertices, and pass down to the pixel shader the viewport
    UV of where they should have been on screen without undistortion. The pixel
    shader can then generate the undistort viewport UV to distort viewport UV
    displacement by just subtracting the pixel's viewport UV.
=============================================================================*/

#include "/Engine/Public/Platform.ush"

Texture2D CopyRectInputTex;
SamplerState CopyInputSampler;
float CopyRectGamma = 1.0;
float ToneMappingType = 1.0;


float3 Uncharted2ToneMapping(float3 color, float adapted_lum)
{
	// 多项式的系数
	const float A = 0.22;
	const float B = 0.30;
	const float C = 0.10;
	const float D = 0.20;
	const float E = 0.01;
	const float F = 0.30;

	//11.2;
	const float WHITE = 11.2; 		// 白色位置，基于经验获得
	
	float3 x = 1.6 * adapted_lum * color;
	float3 res1 = ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
	x = WHITE;
	float3 res2 = ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
	return res1 / res2;
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
float3 ACESFilm(float3 color)
{
	float3 x = 0.8 * color;
	float a = 2.51f;
	float b = 0.03f;
	float c = 2.43f;
	float d = 0.59f;
	float e = 0.14f;
	return saturate((x*(a*x + b)) / (x*(c*x + d) + e));
}

float LinearToSrgbChannel(float lin)
{
	if (lin < 0.00313067) return lin * 12.92;
	return pow(lin, (1.0 / 2.4)) * 1.055 - 0.055;
}

float3 LinearToSrgb(float3 lin)
{
	//return pow(lin, 1/2.2);
	return float3(LinearToSrgbChannel(lin.r), LinearToSrgbChannel(lin.g), LinearToSrgbChannel(lin.b));
}

float3 sRGBToLinear(half3 Color)
{
	Color = max(6.10352e-5, Color); // minimum positive non-denormal (fixes black problem on DX11 AMD and NV)
	return Color > 0.04045 ? pow(Color * (1.0 / 1.055) + 0.0521327, 2.4) : Color * (1.0 / 12.92);
}

float3 ToneMapping(float3 Color)
{
	return LinearToSrgb(ACESFilm(Color));
}

float4 CopyRectPS(
	noperspective float4 UVAndScreenPos : TEXCOORD0
	) : SV_Target0
{
	float2 UV = UVAndScreenPos.xy;
    float4 Color = CopyRectInputTex.Sample(CopyInputSampler, UV);
    return float4(pow(Color.rgb,CopyRectGamma),Color.a);
}


float4 CopyRectToneMappingPS(
	noperspective float4 UVAndScreenPos : TEXCOORD0
	) : SV_Target0
{
	float2 UV = UVAndScreenPos.xy;
    float4 Color = CopyRectInputTex.SampleLevel(CopyInputSampler, UV, 0);
    float Alpha = 1- Color.a;
	bool bUseToneMapping = ToneMappingType >= 1.0;
	CopyRectGamma = 1/2.2;
	//return float4(Color.rgb, Alpha);
	return float4(pow(Color.rgb,CopyRectGamma), Alpha);

}